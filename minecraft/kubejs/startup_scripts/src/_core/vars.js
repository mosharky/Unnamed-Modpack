// priority: 100

global.WOOD_TYPES = {}
global.DISABLED_WOOD_TYPES = {}
global.SWAPPER = new Map()
global.ENTITY_SWAPPER = new Map()
global.BLOCKSWAP_CONFIG = {
    __comment: 'This config was autogenerated from starter_scripts/_core/block_swap.js',
    generate_all_known_states: false,
    retro_gen: false,
    state_swapper: [],
    swapper: new Map()  // becomes an Object after processBlockswapConfig()
}
global.REMOVALS = {
    all: new Set(),
    add: function (entry) {
        if (entry != undefined) {
            if (entry instanceof Array) {
                // Filters out undefined elements
                this.all = new Set(this.getAsArray().concat(entry.filter(e => e !== undefined)))
            } else if (entry.constructor === Object) {
                // Add all strings in an object and any nested objects
                this.add(collectStrings(entry))
            } else {
                this.all.add(entry)
            }
        }
    },
    getAsArray: function () { return Array.from(this.all) },
    getBlocks: function () {
        let blockSet = new Set()
        this.all.forEach(entry => {
            if (Item.of(entry).isBlock()) blockSet.add(entry)
        })
        return blockSet
    },
    getItems: function () {
        let itemSet = new Set()
        this.all.forEach(entry => {
            if (!Item.of(entry).isBlock()) itemSet.add(entry)
        })
        return itemSet
    }
}

global.DEBUG_MODE = true

global.COLOURS = [
    'white',
    'orange',
    'magenta',
    'light_blue',
    'yellow',
    'lime',
    'pink',
    'gray',
    'light_gray',
    'cyan',
    'purple',
    'blue',
    'brown',
    'green',
    'red',
    'black'
]

// Collect all strings in a nested object with recursion
function collectStrings(obj) {
    let strings = []
    for (const key in obj) {
        const value = obj[key]
        if (typeof value === "string") {
            strings.push(value)
        } else if (value === Object(value) && value !== null) {
            strings = strings.concat(collectStrings(value))
        }
    }
    return strings
}

/**
 * Swap a constructed woodType with another
 * @param {Object} woodTypeFrom - ex: `global.DISABLED_WOOD_TYPES.mod.woodType`
 * @param {Object} woodTypeTo - ex: `global.WOOD_TYPES.mod.woodType`
 */
function swapWoodType(woodTypeFrom, woodTypeTo) {
    Object.keys(woodTypeFrom).forEach(entry => {
        Object.keys(woodTypeFrom[entry]).forEach(woodenBlock => {
            global.SWAPPER.set(woodTypeFrom[entry][woodenBlock], woodTypeTo[entry][woodenBlock])
        })
    })
}


// maybe in the future I could construct this from the everycomp config
const woodTypesToConstruct = {
    minecraft: {
        oak: true,
        spruce: true,
        birch: true,
        jungle: true,
        dark_oak: true,
        acacia: true,
        mangrove: true,
        bamboo: true,
        cherry: true,
        crimson: true,
        warped: true,
    },
    quark: {
        azalea: false,
        ancient: false,
        blossom: false,
    },
    vanillabackport: {
        pale_oak: true,
    },
    upgrade_aquatic: {
        driftwood: true,
        river: true,
    },
    atmospheric: {
        grimwood: true,
        rosewood: true,
        morado: true,
        yucca: true,
        aspen: false,
        laurel: true,
        kousa: true,
    },
    environmental: {
        willow: false,
        pine: true,
        plum: true,
        wisteria: false,
    },
    endergetic: {
        poise: true,
    },
    autumnity: {
        maple: true,
    },
    caverns_and_chasms: {
        azalea: true,
    },
    natures_spirit: {
        redwood: true,
        sugi: true,
        wisteria: true,
        fir: true,
        willow: true,
        aspen: true,
        maple: false,
        cypress: true,
        olive: true,
        joshua: true,
        ghaf: true,
        palo_verde: true,
        coconut: true,
        cedar: true,
        larch: true,
        mahogany: true,
        saxaul: true,
    }
}